package sqlez

import (
	"database/sql"
	"encoding/json"
	"errors"
	"fmt"
	"reflect"
	"strconv"
	"strings"
	"time"
)

// Params contains the parameters for the query
type Params struct {
	Where     string
	OrderBy   string
	Limit     int
	SkipEmpty bool
	OrIgnore  bool
}

// DB represents the sqlez database wrapper
type DB struct {
	DB            *sql.DB
	LastQuery     string
	dbTag         string
	dbjsonTag     string
	dbskipTag     string
	jsonPtr       map[*sql.NullString]interface{}
	nullStringPtr map[*sql.NullString]interface{}
}

// Open initiates the connection to the database. It takes the same parameters as the database/sql package, and returns a sqlEZ DB struct. The contained *sql.DB is exported so you can make use of it directly.
func Open(driverName, dataSourceName string) (*DB, error) {
	var ez DB
	var err error

	ez.DB, err = sql.Open(driverName, dataSourceName)
	if err != nil {
		return nil, err
	}

	ez.dbTag, ez.dbjsonTag, ez.dbskipTag = "db", "dbjson", "dbskip"

	return &ez, nil
}

// Close closes the connection to the database
func (s DB) Close() error {
	return s.DB.Close()
}

// SetDBTag changes the struct field tag to look for when searching for database column names.
func (s *DB) SetDBTag(tag string) {
	s.dbTag = tag
}

// SetJSONTag changes the struct field tag to look for when searching for database column names for datatypes that should be saved as JSON.
func (s *DB) SetJSONTag(tag string) {
	s.dbjsonTag = tag
}

// SetSkipTag changes the struct field tag to look for when ignoring embedded structs.
func (s *DB) SetSkipTag(tag string) {
	s.dbskipTag = tag
}

// scanStruct recursively scans a provided struct and returns pointers/interfaces and labels for all items that
// have a "db" tag. Set pointers to true if you want pointers, otherwise interfaces will be returned. Set skipEmpty
// to true if you want to ignore fields that have unset/zero values.
func (s *DB) scanStruct(v reflect.Value, pointers bool, skipEmpty bool, firstRun bool) ([]string, []interface{}, error) {

	if firstRun {
		s.jsonPtr = make(map[*sql.NullString]interface{})
		s.nullStringPtr = make(map[*sql.NullString]interface{})
	}

	var data []interface{}
	var labels []string

	for i := 0; i < v.NumField(); i++ {
		field := v.Field(i)
		fieldt := v.Type().Field(i)

		// Get all the tags, and check if empty/should be skipped
		label, jsonexists := fieldt.Tag.Lookup(s.dbjsonTag)
		dblabel, dbexists := fieldt.Tag.Lookup(s.dbTag)
		_, skiptagexists := fieldt.Tag.Lookup(s.dbskipTag)

		// Ignore all unexported or skipped fields
		if (!jsonexists && !dbexists) || skiptagexists {
			continue
		}

		skip := (skipEmpty && (field.Interface() == reflect.Zero(field.Type()).Interface()))

		if label == "" && dblabel != "" {
			label = dblabel
		}

		// If it is a struct, but we aren't supposed to handle it as json, recursively scan it
		if field.Kind() == reflect.Struct && !jsonexists {
			l, d, e := s.scanStruct(field, pointers, skipEmpty, false)
			if e != nil {
				return nil, nil, e
			}
			labels = append(labels, l...)
			data = append(data, d...)
			continue
		}

		// If it's tagged as json, we need to convert it. We do this automatically for maps.
		if jsonexists || (dbexists && fieldt.Type.Kind() == reflect.Map) {

			// If we are requesting pointers, we must be pulling data from the database. Save a pointer to the actual
			// interface in the buffer, and pass a pointer to a string in the other buffer. After pulling data from the
			// database, Unmarshal the string into the pointer saved in the buffer before returning the data. We can do
			// the same thing with converting strings to NullString.
			if pointers {
				str := new(sql.NullString)
				s.jsonPtr[str] = field.Addr().Interface()
				data = append(data, str)

			} else { // Prepare json to insert into database
				payload, err := json.Marshal(field.Interface())
				if err != nil {
					return nil, nil, errors.New(field.Type().Name() + ": " + err.Error())
				}
				data = append(data, payload)
			}

			labels = append(labels, label)
			continue
		}

		// Otherwise, if it has a DB label let's process it
		if dbexists && !skip {

			labels = append(labels, label)
			if pointers {
				if field.Kind() == reflect.String {
					ns := new(sql.NullString)
					s.nullStringPtr[ns] = field.Addr().Interface()
					data = append(data, ns)
					continue
				}
				data = append(data, field.Addr().Interface())
			} else {
				data = append(data, field.Interface())
			}
		}
	}

	if len(labels) == 0 {
		return nil, nil, fmt.Errorf("sqlez: couldn't find any fields labeled %s or %s ", s.dbTag, s.dbjsonTag)
	}

	return labels, data, nil
}

// CreateTable creates a MySQL table based on struct tags.
func (s *DB) CreateTable(table string, data interface{}) error {
	v := reflect.ValueOf(data)
	if v.Kind() != reflect.Struct {
		return errors.New("sqlez.CreateTable: 'data' must be struct, got " + v.Kind().String())
	}

	var fields []string
	for i := 0; i < v.NumField(); i++ {
		fieldType := v.Type().Field(i)
		dbTag, ok := fieldType.Tag.Lookup(s.dbTag)
		if !ok {
			continue
		}

		dbTagParts := strings.Split(dbTag, ",")
		dbFieldName := dbTagParts[0]
		dbTagOpts := ""
		if len(dbTagParts) > 1 {
			dbTagOpts = "," + strings.Join(dbTagParts[1:], ",")
		}

		dbType := s.getSQLType(fieldType.Type, dbTagOpts)
		fields = append(fields, fmt.Sprintf("%s %s", dbFieldName, dbType))
	}

	if len(fields) == 0 {
		return errors.New("sqlez.CreateTable: couldn't find any fields labeled with the db tag")
	}

	query := fmt.Sprintf("CREATE TABLE %s (%s)", table, strings.Join(fields, ", "))
	s.LastQuery = query
	_, err := s.DB.Exec(query)

	return err
}

// getSQLType maps Go types to SQL types.
func (s *DB) getSQLType(t reflect.Type, tagOpts string) string {
	switch t.Kind() {
	case reflect.String:
		return "VARCHAR(255)" + tagOpts
	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
		return "INT" + tagOpts
	case reflect.Float32, reflect.Float64:
		return "FLOAT" + tagOpts
	case reflect.Bool:
		return "BOOLEAN" + tagOpts
	case reflect.Struct:
		if t == reflect.TypeOf(time.Time{}) {
			return "DATETIME" + tagOpts
		}
	}
	return "TEXT" + tagOpts
}

// unwrapStruct unwraps a struct from a pointer (if necessary) and ensures the returned value is a struct.
func unwrapStruct(s interface{}) (v reflect.Value, err error) {
	v = reflect.ValueOf(s)
	for v.Kind() == reflect.Ptr {
		s = reflect.ValueOf(s).Elem().Interface()
		v = reflect.ValueOf(s)
	}
	if v.Kind() != reflect.Struct {
		err = errors.New("expected struct, got " + v.Kind().String())
	}
	return
}

// SelectFrom performs a "SELECT y FROM x" query on the database and returns a []interface{} of the results.
// Pass in a struct representing the database rows to specify what data you get back.
func (s *DB) SelectFrom(table string, structure interface{}, params ...interface{}) (out []interface{}, err error) {

	var v reflect.Value
	if v, err = unwrapStruct(structure); err != nil {
		return
	}

	copy := reflect.New(v.Type()).Elem()
	labels, pointers, err := s.scanStruct(copy, true, false, true)
	if err != nil {
		return nil, err
	}

	query := "SELECT "
	for i, v := range labels {
		query += v
		if i < len(labels)-1 {
			query += ", "
		}
	}
	query += " FROM " + table

	if len(params) > 0 {

		if reflect.TypeOf(params[0]).String() != "sqlez.Params" {
			return nil, errors.New("sqlez.SelectFrom: third parameter passed wasn't a sqlez.Params")
		}

		p := params[0].(Params)
		params = params[1:]

		if p.Where != "" {
			where := strings.Trim(p.Where, " ,")

			if strings.ToLower(where[:5]) == "where" {
				return nil, errors.New("sqlez.SelectFrom: Params.Where starts with WHERE")
			}
			query += " WHERE " + where
		}

		if p.OrderBy != "" {
			order := strings.Trim(p.OrderBy, " ,")

			if strings.ToLower(order[:5]) == "order" {
				return nil, errors.New("sqlez.SelectFrom: Params.OrderBy starts with ORDER")
			}
			query += " ORDER BY " + order
		}

		if p.Limit > 0 {
			query += " LIMIT " + strconv.Itoa(p.Limit)
		}
	}

	s.LastQuery = query

	var result *sql.Rows
	result, err = s.DB.Query(query, params...)
	if err != nil {
		return
	}

	for result.Next() {
		err = result.Scan(pointers...)
		if err != nil {
			return
		}

		// Unmarshal any strings we have in the buffer
		for i, v := range s.jsonPtr {
			if i.Valid {
				err = json.Unmarshal([]byte(i.String), v)
				if err != nil {
					return nil, errors.New(i.String + ": " + err.Error())
				}

			}
		}

		// Unwrap any sql.NullStrings
		for i, v := range s.nullStringPtr {
			if i.Valid {
				reflect.ValueOf(v).Elem().SetString(i.String)
			}
		}

		out = append(out, copy.Interface())
	}

	err = result.Close()
	if err != nil {
		return
	}

	return
}

// InsertInto performs a "INSERT INTO x (y) VALUES (z)" query on the database and returns the results.
// Pass a struct representing the data you want to insert. Set params.SkipEmpty to true if you want to ignore
// fields in the struct that are unset/zero. Otherwise the zeroed values will be inserted.
func (s *DB) InsertInto(table string, data interface{}, params ...Params) (res sql.Result, err error) {

	p := Params{}
	if params != nil {
		p = params[0]
	}

	var v reflect.Value
	if v, err = unwrapStruct(data); err != nil {
		return
	}

	labels, interfaces, err := s.scanStruct(v, false, p.SkipEmpty, true)
	if err != nil {
		return nil, err
	}

	ignore := ""
	if p.OrIgnore {
		ignore = "IGNORE "
	}

	query := fmt.Sprintf("INSERT %sINTO %s (%s) VALUES (%s)", ignore, table, strings.Join(labels, ", "), strings.Repeat("?, ", len(labels)-1)+"?")
	s.LastQuery = query
	return s.DB.Exec(query, interfaces...)
}

// Update performs an "UPDATE x SET y = z" query on the database and returns the results.
// Pass a struct representing the data you want to update and Params to specify what to update.
func (s *DB) Update(table string, data interface{}, params ...interface{}) (res sql.Result, err error) {

	var v reflect.Value
	if v, err = unwrapStruct(data); err != nil {
		return
	}

	var options string
	var p Params
	if len(params) > 0 {
		if reflect.TypeOf(params[0]).String() != "sqlez.Params" {
			return nil, errors.New("sqlez.Update: third parameter passed wasn't a sqlez.Params")
		}

		p = params[0].(Params)
		params = params[1:]

		if p.Where != "" {
			where := strings.Trim(p.Where, " ,")

			if strings.ToLower(where[:5]) == "where" {
				return nil, errors.New("sqlez.Update: Params.Where starts with WHERE")
			}
			options += " WHERE " + where
		}

		if p.OrderBy != "" {
			order := strings.Trim(p.OrderBy, " ,")

			if strings.ToLower(order[:5]) == "order" {
				return nil, errors.New("sqlez.Update: Params.OrderBy starts with ORDER")
			}
			options += " ORDER BY " + order
		}

		if p.Limit > 0 {
			options += " LIMIT " + strconv.Itoa(p.Limit)
		}
	}

	labels, interfaces, err := s.scanStruct(v, false, p.SkipEmpty, true)
	if err != nil {
		return nil, err
	}

	query := "UPDATE " + table + " SET "
	for i, v := range labels {
		query += v + " = ?"
		if i < len(labels)-1 {
			query += ", "
		}
	}
	query += options

	s.LastQuery = query
	interfaces = append(interfaces, params...)
	return s.DB.Exec(query, interfaces...)
}
